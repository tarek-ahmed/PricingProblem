package evolutionaryAlgorithmForMarketPricing;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import pricingProblem.Main;
import pricingProblem.PricingProblem;
import pricingProblem.PricingProblemHelper;

/**
 * This object represents an evolutionary algorithm to find the best pricing strategy for the Market 
 * Pricing Problem. It uses tournament selection for choosing the parent strategy and order 2 crossover 
 * for generating the child strategies for the next generation. The survival per generation is generational. 
 * @author Tarek Foyz Ahmed
 *
 */
public class EvolutionaryAlgorithmForMarketPricing {
	private PricingProblem pricingProblem;
	private PricingProblemHelper pricingProblemHelper;
	private Population population;
	
	public EvolutionaryAlgorithmForMarketPricing(PricingProblem pricingProblem, PricingProblemHelper pricingProblemHelper){
		this.pricingProblem = pricingProblem;
		this.pricingProblemHelper = pricingProblemHelper;
	}
	
	/**
	 * Runs the Evolutionary Algorithm to find the best strategy for the given market pricing problem instance.
	 */
	public void run() {
		List<Object> bestStrategyOverall = new ArrayList<Object>();
		
		/* Initialise the population */
		this.population = new Population(pricingProblem, this.pricingProblemHelper);
		population.initialise();
		
		/* Find the best strategy overall from the initialised population */
		for(Object[] member : population.getPopulation()) {
			if(bestStrategyOverall.isEmpty() || (double)bestStrategyOverall.get(1) < (double)member[1]) {
				bestStrategyOverall.clear();
				bestStrategyOverall.add(member[0]);
				bestStrategyOverall.add(member[1]);
			}
		}
		
		/* Generations iterations until the fitness evaluations limit is reached */
		while(pricingProblemHelper.getFitnessEvaluationCount() < Main.FITNESS_EVALUATIONS_LIMIT) {
				List<Object> bestStrategyThisGeneration = new ArrayList<Object>();
				
				/* Create next generation population with children generated by current population */
				Population nextGeneration = new Population(pricingProblem, pricingProblemHelper);
				while(nextGeneration.getPopulationSize() < population.getPopulationSize()) {
					ArrayList<double[]> parents = selectParents(population);
					double[] child = createChild(parents.get(0), parents.get(1));
					
					/* Mutates the child strategy based on the mutationProbability */
					int bound = (int) (101 - (Main.MUTATION_PROBABILITY * 100));
					Random r = new Random();
					if(r.nextInt(bound) == 0) {
						child = mutateStrategy(child);
					}
					
					/* Add child to next generation */
					nextGeneration.addMember(child);
					
					/* Checks if the child is best in this generation */
					pricingProblemHelper.incrementFitnessEvaluationCount();
					if(bestStrategyThisGeneration.isEmpty() || (double)bestStrategyThisGeneration.get(1) < pricingProblem.evaluate(child)) {
						bestStrategyThisGeneration.clear();
						bestStrategyThisGeneration.add(child);
						bestStrategyThisGeneration.add(pricingProblem.evaluate(child));
						/* Then checks if best overall */
						if(bestStrategyOverall.isEmpty() || (double)bestStrategyOverall.get(1) < pricingProblem.evaluate(child)) {
							bestStrategyOverall.clear();
							bestStrategyOverall.add(child);
							bestStrategyOverall.add(pricingProblem.evaluate(child));
						}
					}
				}
				
				/* Replace old generation with the new generation */
				population = nextGeneration;
				
				/* Print generation result */
				if(Main.PRINT_ALL_ITERATIONS == true) {	
					System.out.print(" Best strategy from this generation has a TOTAL REVENUE of £" + bestStrategyThisGeneration.get(1) + " which is when:");
					pricingProblemHelper.printStrategy(((double[])bestStrategyThisGeneration.get(0)));
					System.out.println();
				}
				
				/* Add chart data */
				Main.EASeries.add(pricingProblemHelper.getFitnessEvaluationCount(), (double)bestStrategyThisGeneration.get(1));
				Double[] value = {(double)pricingProblemHelper.getFitnessEvaluationCount(), (double)bestStrategyThisGeneration.get(1)};
				Main.EAValues.add(value);
		}
		
		if(Main.PRINT_ALL_ITERATIONS == true) {	
			System.out.println();
			System.out.println("FITNESS EVALUATIONS LIMIT REACHED!");
		}
		/* Print overall result */
		System.out.println("-----------------------------------------------------------------------------EVOLUTION ALGORITHM COMPLETE!-----------------------------------------------------------------------------");
		System.out.println("Best strategy found overall is where TOTAL REVENUE = £" + bestStrategyOverall.get(1) + " which is when:");
		pricingProblemHelper.printStrategy(((double[])bestStrategyOverall.get(0)));
		System.out.println();
		System.out.println("---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------");
		System.out.println();
		System.out.println();
	}
	
	/**
	 * Uses tournament selection to select and return the parent strategies in the form of a list.
	 * @param parentSelectionTournamentSize - The size of the tournament to select parents from.
	 * @return ArrayList<double[]>
	 */
	public ArrayList<double[]> selectParents(Population population){
		ArrayList<Object[]> potentialParents = new ArrayList<Object[]>();
		Random r = new Random();
		
		/* Creates the list of potential parents who will compete in the tournament */
		while (potentialParents.size() < Main.PARENT_SELECTION_TOURNAMENT_SIZE) {
			Object[] potentialParent = population.getPopulation().get(r.nextInt(population.getPopulationSize()));
			
			if(potentialParents.isEmpty()) {
				potentialParents.add(potentialParent);
			}
			else {
				potentialParents.add(potentialParent);
			}
		}
		
		/* Generates parent 1 as the strategy with the highest total revenue */
		ArrayList<Object> parent1 = new ArrayList<Object>();
		for(Object[] member: potentialParents) {
			if(parent1.isEmpty() || (double)parent1.get(1) < (double)member[1]) {
				parent1.clear();
				parent1.add(member[0]);
				parent1.add(member[1]);
			}
		}
		
		/* Generates parent 2 as the strategy with the second highest total revenue */
		ArrayList<Object> parent2 = new ArrayList<Object>();
		for(Object[] member: potentialParents) {
			if((parent2.isEmpty() && !(Arrays.equals(((double[])parent1.get(0)), ((double[])member[0])))) || ((!parent2.isEmpty()) && (double)parent2.get(1) < (double)member[1] && !(Arrays.equals(((double[])parent1.get(0)), ((double[])member[0]))))) {
				parent2.clear();
				parent2.add(member[0]);
				parent2.add(member[1]);
			}
			else {
				/* Novel idea: Add a random parent strategy if 2 parents are the same */
				pricingProblemHelper.incrementFitnessEvaluationCount();
				parent2.clear();
				parent2.add((potentialParents.get(r.nextInt(potentialParents.size())))[0]);
				parent2.add(pricingProblem.evaluate((double[]) parent2.get(0)));
			}
		}
		
		/* Return the 2 best parents */
		ArrayList<double[]> parents = new ArrayList<double[]>();
		parents.add((double[])parent1.get(0));
		parents.add((double[])parent2.get(0));
		return parents;
	}
	
	/**
	 * Takes in 2 parent strategies and uses order 2 crossover with the @param crossoverSetSize to generate
	 * and return a child strategy.
	 * @param parent1 double[] - The first parent strategy.
	 * @param parent2 double[] - The second parent strategy.
	 * @return double[] 
	 */
	public double[] createChild(double[] parent1, double[] parent2) {
		int strategySize = parent1.length;
		
		ArrayList<Double> randomSelectionFromFirstParent = new ArrayList<Double>();
		ArrayList<Double> restFromSecondParent = new ArrayList<Double>();
		
		Random r = new Random();
		int startingIndex = r.nextInt(strategySize - 1);
		
		int i;
		
		/* Grab the set of item identifiers from the first parent starting from the random starting index */
		i = startingIndex;
		
		while(randomSelectionFromFirstParent.size() < Main.CROSSOVER_SET_SIZE) {
			randomSelectionFromFirstParent.add(parent1[i]);
			if(i == parent1.length - 1) {
				i = 0;
			}
			else {
				i++;
			}
		}
		
		/* Grab rest of the locations in the same order from second parent */
		i = (startingIndex + randomSelectionFromFirstParent.size()) % strategySize;
		
		while(restFromSecondParent.size() < (parent2.length - randomSelectionFromFirstParent.size())) {
			restFromSecondParent.add(parent2[i]);

			if(i == parent2.length - 1) {
				i = 0;
			}
			else {
				i++;
			}
		}
		
		/* Construct child strategy */
		ArrayList<Double> childStrategyAsList = new ArrayList<Double>();
		
		for(int x = 0; x < strategySize; x++) {
			childStrategyAsList.add(x, null);
		}
		
		i = startingIndex;
		
		while(true) {
			for(double price : randomSelectionFromFirstParent) {
				childStrategyAsList.set(i, price);
				if(i == parent2.length - 1) {
					i = 0;
					continue;
				}
				i++;
			}
			for(double price : restFromSecondParent) {
				childStrategyAsList.set(i, price);
				if(i == parent2.length - 1) {
					i = 0;
					continue;
				}
				i++;
			}
			break;
		}
		
		double[] childStrategy = new double[strategySize];
		
		for(int j = 0; j < childStrategyAsList.size(); j++) {
			childStrategy[j] = childStrategyAsList.get(j);
		}
		
		return childStrategy;
	}
	
	/**
	 * Gets the neighbourhood of the @param strategy from which it randomly selects and returns a strategy from to mutate the @param strategy. 
	 * @param strategy Strategy - The strategy to mutate.
	 * @return Strategy
	 */
	public double[] mutateStrategy(double[] strategy) {
		ArrayList<double[]> neighbourhood = pricingProblemHelper.getNeighbourhood(strategy);
		Random r = new Random();
		return neighbourhood.get(r.nextInt(neighbourhood.size()-1));
	}
}
